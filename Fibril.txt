#     def make_final_mesh(self):
        
#         N = 64  # Number of vertices along midline
#         N_taper = int(N / 4)  # Number of points to taper at the ends
#         shape_k1 = 1.  # Changes shape at midpoint
#         shape_k2 = 1.  # Changes shape at endpoint

#         u = np.linspace(0, self.length, N) - self.length / 2
#         theta = np.linspace(0, 2 * np.pi, N)

#         # Midline as straight line
#         X = np.stack([u, np.zeros_like(u), np.zeros_like(u)], axis=1)
# #         X = rotate_points(X, angle[0], angle[1])
# #         X = translate_points(X, center)

#         # Define the tapered radius as a function of midline
#         t = np.linspace(0, np.pi / 2, N_taper)
#         x_t = N_taper * np.cos(t)**shape_k1
#         r_t = self.radius * np.sin(t)**shape_k2

#         # Resample to get equally spaced points

#         f = interp1d(x_t, r_t, kind='cubic', fill_value='extrapolate')
#         x_taper = np.linspace(0, N_taper, N_taper)
#         r_taper = f(x_taper) # interpolate y to fit new x (t_idxs)

#         # Concatenate sections to get radius as function of midline
#         r = np.concatenate([
#             r_taper[::-1], # tapered section
#             np.ones(N - 2 * N_taper) * self.radius, # midsection (constant radius)
#             r_taper # tapered section
#         ])

#         # Calculate a TNB frame from the midline
#         T = normalize(np.gradient(X, axis=0))
#         N = normalize(np.cross(T, np.ones_like(T) * [0, 0, 1]))
#         B = np.cross(T, N)

#         # Generate surface
#         x = X[:, 0] + r * (np.outer(np.cos(theta), N[:, 0]) + np.outer(np.sin(theta), B[:, 0]))
#         y = X[:, 1] + r * (np.outer(np.cos(theta), N[:, 1]) + np.outer(np.sin(theta), B[:, 1]))
#         z = X[:, 2] + r * (np.outer(np.cos(theta), N[:, 2]) + np.outer(np.sin(theta), B[:, 2]))

#         x_p = np.ravel(x)
#         y_p = np.ravel(y)
#         z_p = np.ravel(z)
#         pts = np.stack([x_p, y_p, z_p], axis=1)

#         mesh = trimesh.PointCloud(pts).convex_hull
#         mesh = self.transform_mesh(mesh, [1, 0, 0], override=True)
#         self.mesh = mesh